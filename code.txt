/db/models/user.model.ts
export interface User {
    id: string;
    name: string;
    likedSongs: string[]; // Array of track IDs
    playlists: Playlist[];
    onboarding: boolean;
}

export interface Playlist {
    id: string;
    name: string;
    tracks: string[]; // Array of track IDs
    createdAt: Date;
}
/db/models/tracks.model.ts
export interface Track {
    id: string;
    title: string;
    author?: string;
    album?: string;
    src: string;
    cover?: string;
    type?: string;
}
/db/actions/user.actions.ts
import { v4 as uuidv4 } from 'uuid';
import db from '../index';
import { User, Playlist } from '../models/model.user';
import { Track } from '../models/model.tracks';
import { getTracksByIds } from './action.tracks';

// Get the current user (create one if it doesn't exist)
export async function getCurrentUser(): Promise<User> {
    const users = await db.users.toArray();

    if (users.length === 0) {
        // Create a default user if none exists
        const newUser: User = {
            id: uuidv4(),
            name: 'User',
            likedSongs: [],
            playlists: [],
            onboarding: false
        };

        await db.users.add(newUser);
        return newUser;
    }

    // Return the first user (we're only supporting one user in this simple app)
    return users[0];
}

// Update user name and complete onboarding
export async function completeOnboarding(name: string): Promise<User> {
    const user = await getCurrentUser();

    const updatedUser: User = {
        ...user,
        name,
        onboarding: true
    };

    await db.users.update(user.id, {
        name: updatedUser.name,
        onboarding: updatedUser.onboarding
    });
    return updatedUser;
}

// Check if user has completed onboarding
export async function hasCompletedOnboarding(): Promise<boolean> {
    const user = await getCurrentUser();
    return user.onboarding;
}

// Add a track to liked songs
export async function likeSong(trackId: string): Promise<void> {
    const user = await getCurrentUser();

    if (!user.likedSongs.includes(trackId)) {
        const updatedUser: User = {
            ...user,
            likedSongs: [...user.likedSongs, trackId]
        };

        await db.users.update(user.id, {
            likedSongs: updatedUser.likedSongs
        });
    }
}

// Remove a track from liked songs
export async function unlikeSong(trackId: string): Promise<void> {
    const user = await getCurrentUser();

    const updatedUser: User = {
        ...user,
        likedSongs: user.likedSongs.filter(id => id !== trackId)
    };

    await db.users.update(user.id, {
        likedSongs: updatedUser.likedSongs
    });
}

// Check if a song is liked
export async function isSongLiked(trackId: string): Promise<boolean> {
    const user = await getCurrentUser();
    return user.likedSongs.includes(trackId);
}

// Get all liked songs
export async function getLikedSongs(): Promise<Track[]> {
    const user = await getCurrentUser();
    return await getTracksByIds(user.likedSongs);
}

// Create a new playlist
export async function createPlaylist(name: string): Promise<Playlist> {
    const user = await getCurrentUser();

    const newPlaylist: Playlist = {
        id: uuidv4(),
        name,
        tracks: [],
        createdAt: new Date()
    };

    const updatedUser: User = {
        ...user,
        playlists: [...user.playlists, newPlaylist]
    };

    await db.users.update(user.id, {
        playlists: updatedUser.playlists
    });
    return newPlaylist;
}

// Add a track to a playlist
export async function addTrackToPlaylist(playlistId: string, trackId: string): Promise<void> {
    const user = await getCurrentUser();

    const updatedPlaylists = user.playlists.map(playlist => {
        if (playlist.id === playlistId && !playlist.tracks.includes(trackId)) {
            return {
                ...playlist,
                tracks: [...playlist.tracks, trackId]
            };
        }
        return playlist;
    });

    const updatedUser: User = {
        ...user,
        playlists: updatedPlaylists
    };

    await db.users.update(user.id, {
        playlists: updatedUser.playlists
    });
}

// Remove a track from a playlist
export async function removeTrackFromPlaylist(playlistId: string, trackId: string): Promise<void> {
    const user = await getCurrentUser();

    const updatedPlaylists = user.playlists.map(playlist => {
        if (playlist.id === playlistId) {
            return {
                ...playlist,
                tracks: playlist.tracks.filter(id => id !== trackId)
            };
        }
        return playlist;
    });

    const updatedUser: User = {
        ...user,
        playlists: updatedPlaylists
    };

    await db.users.update(user.id, {
        playlists: updatedUser.playlists
    });
}

// Delete a playlist
export async function deletePlaylist(playlistId: string): Promise<void> {
    const user = await getCurrentUser();

    const updatedUser: User = {
        ...user,
        playlists: user.playlists.filter(playlist => playlist.id !== playlistId)
    };

    await db.users.update(user.id, {
        playlists: updatedUser.playlists
    });
}

// Get a playlist by ID with its tracks
export async function getPlaylistWithTracks(playlistId: string): Promise<{ playlist: Playlist, tracks: Track[] } | null> {
    const user = await getCurrentUser();

    const playlist = user.playlists.find(p => p.id === playlistId);
    if (!playlist) return null;

    const tracks = await getTracksByIds(playlist.tracks);

    return { playlist, tracks };
}

// Get all playlists
export async function getAllPlaylists(): Promise<Playlist[]> {
    const user = await getCurrentUser();
    return user.playlists;
}
/db/actions/tracks.actions.ts
import db from '../index';
import { Track } from '../models/model.tracks';

export async function syncTracksFromAPI(): Promise<Track[]> {
    try {
        // Fetch tracks from the API
        const response = await fetch('/api/tracks');
        if (!response.ok) {
            throw new Error(`Failed to fetch tracks: ${response.status}`);
        }

        const newTracks: Track[] = await response.json();

        // Store tracks in the database while preserving existing tracks
        await db.transaction('rw', db.tracks, async () => {
            // Get existing tracks
            const existingTracks = await db.tracks.toArray();
            const existingIds = new Set(existingTracks.map(track => track.id));

            // Add only new tracks
            const tracksToAdd = newTracks.filter(track => !existingIds.has(track.id));

            // Update existing tracks
            const tracksToUpdate = newTracks.filter(track => existingIds.has(track.id));

            // Add new tracks
            if (tracksToAdd.length > 0) {
                await db.tracks.bulkAdd(tracksToAdd);
            }

            // Update existing tracks
            for (const track of tracksToUpdate) {
                await db.tracks.update(track.id, track);
            }
        });

        return newTracks;
    } catch (error) {
        console.error('Error syncing tracks:', error);
        throw error;
    }
}

// Get all tracks from the database
export async function getAllTracks(): Promise<Track[]> {
    return await db.tracks.toArray();
}

// Get a track by ID
export async function getTrackById(id: string): Promise<Track | undefined> {
    return await db.tracks.get(id);
}

// Get tracks by IDs
export async function getTracksByIds(ids: string[]): Promise<Track[]> {
    return await db.tracks.where('id').anyOf(ids).toArray();
}

// Search tracks by title or author
export async function searchTracks(query: string): Promise<Track[]> {
    const lowerQuery = query.toLowerCase();

    return await db.tracks.filter((track: Track) => {
        const titleMatch = track.title.toLowerCase().includes(lowerQuery);
        const authorMatch = track.author ? track.author.toLowerCase().includes(lowerQuery) : false;

        return titleMatch || authorMatch;
    }).toArray();
}
/db/index.ts
import Dexie, { Table } from 'dexie';
import { Track } from './models/model.tracks';
import { User } from './models/model.user';

export class MusicAppDatabase extends Dexie {
    tracks!: Table<Track>;
    users!: Table<User>;

    constructor() {
        super('MusicAppDatabase');
        this.version(1).stores({
            tracks: 'id, title, author, album, src, cover, type',
            users: 'id, name, onboarding',
        });
    }
}

// Create a single instance of the database to be used throughout the app
const db = new MusicAppDatabase();

export default db;
/hooks/useTracks.ts
"use client"

import { useState, useEffect, useCallback } from "react";
import { useAudio } from "@/components/player/AudioContext";

export const useTracks = (...trackNames: string[]) => {
  const [tracks, setTracks] = useState<Track[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const { 
    playTrackAtIndex,
    isPlaying,
    togglePlayPause,
    currentTime,
    duration
  } = useAudio();

  useEffect(() => {
    const fetchTracks = async () => {
      try {
        setIsLoading(true);

        let url = '/api/tracks';
        // If track names are provided, add them as query parameters
        if (trackNames.length > 0) {
          const queryParams = new URLSearchParams();
          trackNames.forEach(name => queryParams.append('tracks', name));
          url = `${url}?${queryParams.toString()}`;
        }

        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`Failed to fetch tracks: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();

        if (Array.isArray(data) && data.length > 0) {
          setTracks(data);
        } else {
          setError('No tracks found. Please add some music files to the tracks directory.');
        }
      } catch (err) {
        console.error('Error fetching tracks:', err);
        setError(err instanceof Error ? err.message : 'Unknown error fetching tracks');
      } finally {
        setIsLoading(false);
      }
    };

    fetchTracks();
  }, [trackNames.join(',')]); // Re-fetch when track list changes

  // Handle track selection
  const handleTrackSelect = useCallback((index: number) => {
    playTrackAtIndex(index, tracks);
  }, [playTrackAtIndex, tracks]);

  return {
    tracks,
    isPlaying,
    isLoading,
    error,
    currentTime,
    duration,
    handleTrackSelect,
    handlePlayPauseToggle: togglePlayPause
  };
};
/components/shared/LikeButton.tsx
"use client"

import { Heart } from 'lucide-react';
import { useState, useEffect } from 'react';
import { isSongLiked, likeSong, unlikeSong } from '@/db/actions/action.user';

interface LikeButtonProps {
    trackId: string;
    size?: 'sm' | 'md' | 'lg';
    className?: string;
    onLikeStateChange?: (isLiked: boolean) => void;
}

export const LikeButton = ({ trackId, size = 'md', className = '', onLikeStateChange }: LikeButtonProps) => {
    const [isLiked, setIsLiked] = useState<boolean>(false);
    const [isLoading, setIsLoading] = useState<boolean>(true);

    // Get sizes based on the size prop
    const sizeClass = size === 'sm' ? 'w-4 h-4' : size === 'lg' ? 'w-6 h-6' : 'w-5 h-5';

    // Check initial like status
    useEffect(() => {
        const checkLikeStatus = async () => {
            if (!trackId) return;

            try {
                setIsLoading(true);
                const liked = await isSongLiked(trackId);
                setIsLiked(liked);
            } catch (error) {
                console.error('Error checking if song is liked:', error);
            } finally {
                setIsLoading(false);
            }
        };

        checkLikeStatus();
    }, [trackId]);

    const toggleLike = async (e: React.MouseEvent) => {
        e.stopPropagation(); // Prevent event bubbling (important for track selection)

        if (!trackId || isLoading) return;

        try {
            setIsLoading(true);

            if (isLiked) {
                await unlikeSong(trackId);
            } else {
                await likeSong(trackId);
            }

            const newLikedState = !isLiked;
            setIsLiked(newLikedState);

            // Notify parent component if callback provided
            if (onLikeStateChange) {
                onLikeStateChange(newLikedState);
            }
        } catch (error) {
            console.error('Error toggling like status:', error);
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <button
            onClick={toggleLike}
            disabled={isLoading}
            className={`transition-all duration-200 ${className}`}
            aria-label={isLiked ? "Unlike" : "Like"}
            title={isLiked ? "Unlike" : "Like"}
        >
            <Heart
                className={`${sizeClass} ${isLiked ? 'fill-red-500 text-red-500' : 'text-gray-500 hover:text-gray-700'} ${isLoading ? 'opacity-50' : ''}`}
            />
        </button>
    );
};
/api/tracks/route.ts
import path from 'path';
import crypto from 'crypto';
import fs from 'fs/promises';
import * as NodeID3 from 'node-id3';

import { NextRequest, NextResponse } from 'next/server';
import { Track } from '@/db/models/model.tracks';

// Generate a consistent ID based on the file properties
function generateConsistentId(filename: string, fileSize: number): string {
  const hash = crypto.createHash('md5');
  hash.update(`${filename}-${fileSize}`);
  return hash.digest('hex');
}

async function fileHash(filePath: string): Promise<string> {
  const fileBuffer = await fs.readFile(filePath);
  const hashSum = crypto.createHash('sha256');
  hashSum.update(fileBuffer);
  return hashSum.digest('hex');
}

const coverCache: { [key: string]: string } = {};

async function getCoverFromCache(hash: string, coverFilename: string, imageBuffer: Buffer): Promise<string> {
  if (!coverCache[hash]) {
    await fs.writeFile(path.join(process.cwd(), 'public', 'covers', coverFilename), imageBuffer);
    coverCache[hash] = `/covers/${coverFilename}`;
  }
  return coverCache[hash];
}

async function getTracks(requestedTracks?: string[]): Promise<Track[]> {
  const tracksDirectory = path.join(process.cwd(), 'public', 'tracks');

  try {
    const filenames = await fs.readdir(tracksDirectory);
    const tracksData: Track[] = [];

    // Filter filenames if requestedTracks is provided
    const filteredFilenames = requestedTracks && requestedTracks.length > 0
      ? filenames.filter(filename => requestedTracks.includes(filename))
      : filenames;

    for (const filename of filteredFilenames) {
      if (['.mp3', '.wav', '.flac', '.m4a'].includes(path.extname(filename).toLowerCase())) {
        const filePath = path.join(tracksDirectory, filename);
        const stats = await fs.stat(filePath);
        
        // Generate consistent ID based on filename and filesize
        const fileId = generateConsistentId(filename, stats.size);
        
        const fileType = path.extname(filename).toLowerCase().substring(1);
        let title = filename.replace(/\.[^.]+$/, '').replace(/_/g, ' ').replace(/-/g, ' ');
        let author: string | undefined;
        let album: string | undefined;
        let cover: string | undefined = '/default-cover.jpg';

        if (path.extname(filename).toLowerCase() === '.mp3') {
          try {
            const tags = NodeID3.read(filePath);
            if (tags) {
              title = tags.title || title;
              author = tags.artist || tags.composer;
              album = tags.album;

              // Handle cover image from ID3 tags
              if (
                tags.image &&
                typeof tags.image !== 'string' &&
                tags.image.imageBuffer
              ) {
                try {
                  const hash = await fileHash(filePath);
                  const coverFilename = `${hash}-cover.jpg`;
                  const coverPath = path.join(process.cwd(), 'public', 'covers');
                  await fs.mkdir(coverPath, { recursive: true });

                  if (!coverCache[hash]) {
                    // Save the cover to public folder for serving only if it's not in the cache
                    try {
                      cover = await getCoverFromCache(hash, coverFilename, tags.image.imageBuffer);
                    } catch (err) {
                      console.error(`Error saving cover image for ${filename}:`, err);
                      cover = `/default-cover.png`;
                    }
                  } else {
                    cover = coverCache[hash];
                  }
                } catch (err) {
                  console.error(`Error saving cover image for ${filename}:`, err);
                }
              }
            }
          } catch (error) {
            console.error(`Error reading ID3 tags from ${filename}:`, error);
          }
        }

        tracksData.push({
          id: fileId,
          title: title,
          author: author || 'Unknown Artist',
          album: album || 'Unknown Album',
          src: `/tracks/${filename}`,
          cover: cover,
          type: fileType,
        });
      }
    }

    return tracksData;
  } catch (error) {
    console.error("Error reading tracks directory:", error);
    return [];
  }
}

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const requestedTracks = searchParams.getAll('tracks');

  const tracks = await getTracks(requestedTracks.length > 0 ? requestedTracks : undefined);
  return NextResponse.json(tracks);
}
/components/FetchTracks.tsx
"use client"

import Image from 'next/image';

import { memo, useCallback } from 'react';
import { Play, Pause, Music } from 'lucide-react';
import { useAudio } from '@/components/player/AudioContext';
import { LikeButton } from '@/components/shared/LikeButton';

interface FetchTracksProps {
  tracks: Track[];
  isLoading: boolean;
  error: string | null;
  handleTrackSelect: (index: number) => void;
  layout?: 'blocks' | 'list';
  variant?: 'flex' | 'grid';
}

export const FetchTracks = memo(({
  tracks,
  isLoading,
  error,
  handleTrackSelect,
  layout = 'blocks',
  variant = 'flex'
}: FetchTracksProps) => {
  const { isPlaying, currentTrackIndex, tracks: currentTracks } = useAudio();

  // Format time display (e.g., 01:45)
  const formatTime = useCallback((time: number): string => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
  }, []);

  // Check if a track is the currently playing track
  const isTrackPlaying = (track: Track) => {
    if (!isPlaying) return false;

    const currentTrack = currentTracks[currentTrackIndex];
    return currentTrack && currentTrack.id === track.id;
  };

  if (isLoading) {
    return <div className="text-start py-4">Заргужаем песни...</div>;
  }

  if (error) {
    return <div className="text-center text-red-500 py-4">{error}</div>;
  }

  if (tracks.length === 0) {
    return <div className="text-start py-4">Песни не найдены.</div>;
  }

  // Render tracks in block layout (grid or flex of cards)
  if (layout === 'blocks') {
    return (
      <div className={variant === 'grid'
        ? "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4"
        : "flex flex-row overflow-x-auto overflow-y-hidden gap-4 w-full"
      }>
        {tracks.map((track, index) => (
          <div
            key={track.id}
            className="relative flex flex-col items-start group cursor-pointer min-w-[150px] sm:min-w-[200px]"
          >
            <div
              className="relative w-full"
              onClick={() => handleTrackSelect(index)}
            >
              <Image
                src={track.cover || '/default-cover.jpg'}
                alt={track.title}
                width={200}
                height={200}
                className="rounded-lg w-full object-cover"
              />
              <div className="absolute flex items-center justify-center inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-200 bg-black/20 backdrop-blur-[3px] rounded-lg">
                {isTrackPlaying(track) ? (
                  <Pause className="w-8 h-8 text-white" />
                ) : (
                  <Play className="w-8 h-8 text-white" />
                )}
              </div>
            </div>
            <div className="mt-2 sm:mt-4 text-start w-full flex items-center justify-between">
              <div onClick={() => handleTrackSelect(index)}>
                <h3 className="font-semibold">{track.title}</h3>
                <p className="text-sm text-gray-500">{track.author}</p>
              </div>
              <LikeButton trackId={track.id} size="md" className="ml-2" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  // Render tracks in list layout (Spotify-like list)
  return (
    <div className="w-full border border-gray-200 rounded-md divide-y">
      {tracks.map((track, index) => (
        <div
          key={track.id}
          className={`flex items-center p-3 hover:bg-gray-50 cursor-pointer ${isTrackPlaying(track) ? 'bg-gray-50' : ''}`}
        >
          <div
            className="flex items-center flex-1 min-w-0"
            onClick={() => handleTrackSelect(index)}
          >
            <div className="relative flex-shrink-0 w-12 h-12 mr-3">
              {track.cover ? (
                <Image
                  src={track.cover}
                  alt={track.title}
                  width={48}
                  height={48}
                  className="rounded object-cover"
                />
              ) : (
                <div className="flex items-center justify-center bg-gray-200 rounded w-full h-full">
                  <Music className="w-6 h-6 text-gray-500" />
                </div>
              )}
              <div className="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100">
                {isTrackPlaying(track) ? (
                  <Pause className="w-6 h-6 text-white" />
                ) : (
                  <Play className="w-6 h-6 text-white" />
                )}
              </div>
            </div>

            <div className="min-w-0 flex-1">
              <h4 className="font-medium truncate">{track.title}</h4>
              <p className="text-sm text-gray-500 truncate">{track.author}</p>
            </div>
          </div>

          <div className="flex items-center space-x-4">
            {isTrackPlaying(track) ? (
              <span className="text-xs font-medium text-green-600 w-16 text-right">Playing</span>
            ) : (
              <span className="text-xs text-gray-500 w-16 text-right"></span>
            )}
            <LikeButton trackId={track.id} size="md" />
          </div>
        </div>
      ))}
    </div>
  );
});
/page.tsx
"use client"

import { useTracks } from "@/hooks/useTracks";
import { FetchTracks } from "@/components/shared/FetchTracks";

const Page = () => {
    const collection = useTracks("Fell In Love.mp3", "VOGUE - Lil Tecca.mp3");
    const cartiCollection = useTracks("Magnolia.mp3", "Racks Up.mp3");

    return (
        <section className="flex flex-col w-full">
            <div className="container">
                <div className="flex flex-col gap-4 mb-8">
                    <div className="flex flex-row items-center justify-between">
                        <h1 className="title-text">Lil Tecca</h1>
                        <p className="link-text">Смотреть все</p>
                    </div>
                    <FetchTracks
                        tracks={collection.tracks}
                        isLoading={collection.isLoading}
                        error={collection.error}
                        handleTrackSelect={collection.handleTrackSelect}
                    />
                </div>
                <div className="flex flex-col gap-4 mb-8">
                    <div className="flex flex-row items-center justify-between">
                        <h1 className="title-text">PlayboiCarti</h1>
                        <p className="link-text">Смотреть все</p>
                    </div>
                    <FetchTracks
                        tracks={cartiCollection.tracks}
                        isLoading={cartiCollection.isLoading}
                        error={cartiCollection.error}
                        handleTrackSelect={cartiCollection.handleTrackSelect}
                    />
                </div>
            </div>
        </section>
    );
};

export default Page;