/route.ts
import path from 'path';
import crypto from 'crypto';
import fs from 'fs/promises';
import * as NodeID3 from 'node-id3';

import { NextRequest, NextResponse } from 'next/server';
import { Track } from '@/db/models/tracks.model';

// Generate a consistent ID based on the file properties
function generateConsistentId(filename: string, fileSize: number): string {
  const hash = crypto.createHash('md5');
  hash.update(`${filename}-${fileSize}`);
  return hash.digest('hex');
}

async function fileHash(filePath: string): Promise<string> {
  const fileBuffer = await fs.readFile(filePath);
  const hashSum = crypto.createHash('sha256');
  hashSum.update(fileBuffer);
  return hashSum.digest('hex');
}

const coverCache: { [key: string]: string } = {};

async function getCoverFromCache(hash: string, coverFilename: string, imageBuffer: Buffer): Promise<string> {
  // Check if we're in a production environment
  const isProduction = process.env.NODE_ENV === 'production';

  // For production environments, use data URLs
  if (isProduction) {
    const base64Image = imageBuffer.toString('base64');
    return `data:image/jpeg;base64,${base64Image}`;
  }

  // For development, continue using file system
  if (!coverCache[hash]) {
    const coverPath = path.join(process.cwd(), 'public', 'covers');
    await fs.mkdir(coverPath, { recursive: true });
    await fs.writeFile(path.join(coverPath, coverFilename), imageBuffer);
    coverCache[hash] = `/covers/${coverFilename}`;
  }
  return coverCache[hash];
}
async function getTracks(requestedTracks?: string[]): Promise<Track[]> {
  const tracksDirectory = path.join(process.cwd(), 'public', 'tracks');

  try {
    const filenames = await fs.readdir(tracksDirectory);
    const tracksData: Track[] = [];

    // Filter filenames if requestedTracks is provided
    const filteredFilenames = requestedTracks && requestedTracks.length > 0
      ? filenames.filter(filename => requestedTracks.includes(filename))
      : filenames;

    for (const filename of filteredFilenames) {
      if (['.mp3', '.wav', '.flac', '.m4a'].includes(path.extname(filename).toLowerCase())) {
        const filePath = path.join(tracksDirectory, filename);
        const stats = await fs.stat(filePath);

        // Generate consistent ID based on filename and filesize
        const fileId = generateConsistentId(filename, stats.size);

        const fileType = path.extname(filename).toLowerCase().substring(1);
        let title = filename.replace(/\.[^.]+$/, '').replace(/_/g, ' ').replace(/-/g, ' ');
        let author: string | undefined;
        let album: string | undefined;
        let cover: string | undefined = '/default-cover.jpg';

        if (path.extname(filename).toLowerCase() === '.mp3') {
          try {
            const tags = NodeID3.read(filePath);
            if (tags) {
              title = tags.title || title;
              author = tags.artist || tags.composer;
              album = tags.album;

              // Handle cover image from ID3 tags
              if (
                tags.image &&
                typeof tags.image !== 'string' &&
                tags.image.imageBuffer
              ) {
                try {
                  const hash = await fileHash(filePath);
                  const coverFilename = `${hash}-cover.jpg`;
                  const coverPath = path.join(process.cwd(), 'public', 'covers');
                  await fs.mkdir(coverPath, { recursive: true });

                  if (!coverCache[hash]) {
                    // Save the cover to public folder for serving only if it's not in the cache
                    try {
                      cover = await getCoverFromCache(hash, coverFilename, tags.image.imageBuffer);
                    } catch (err) {
                      console.error(`Error saving cover image for ${filename}:`, err);
                      cover = `/default-cover.png`;
                    }
                  } else {
                    cover = coverCache[hash];
                  }
                } catch (err) {
                  console.error(`Error saving cover image for ${filename}:`, err);
                }
              }
            }
          } catch (error) {
            console.error(`Error reading ID3 tags from ${filename}:`, error);
          }
        }

        tracksData.push({
          id: fileId,
          title: title,
          author: author || 'Unknown Artist',
          album: album || 'Unknown Album',
          src: `/tracks/${filename}`,
          cover: cover,
          type: fileType,
        });
      }
    }

    return tracksData;
  } catch (error) {
    console.error("Error reading tracks directory:", error);
    return [];
  }
}

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const requestedTracks = searchParams.getAll('tracks');

  // Add pagination parameters
  const page = parseInt(searchParams.get('page') || '1', 10);
  const limit = parseInt(searchParams.get('limit') || '10', 10);

  const allTracks = await getTracks(requestedTracks.length > 0 ? requestedTracks : undefined);

  // Calculate pagination
  const startIndex = (page - 1) * limit;
  const endIndex = startIndex + limit;
  const paginatedTracks = allTracks.slice(startIndex, endIndex);

  // Return paginated data with metadata
  return NextResponse.json({
    tracks: paginatedTracks,
    total: allTracks.length,
    page,
    limit,
    totalPages: Math.ceil(allTracks.length / limit)
  });
}

/useTracks.tsx
"use client"

import { Track } from "@/db/models/tracks.model";
import { useAudio } from "@/components/player/AudioContext";
import { useState, useEffect, useCallback, useMemo, useRef } from "react";

// Create a global cache for track data with better typing
interface CacheEntry {
  data: Track[];
  timestamp: number;
  expiryTime: number;
  total?: number;
  totalPages?: number;
}

interface TracksCache {
  [key: string]: CacheEntry
}

// Move cache outside of the component to persist between renders
const tracksCache: TracksCache = {};
const CACHE_EXPIRY = 60 * 60 * 1000; // 1 hours

// Add localStorage persistence for the cache
const initializeCache = () => {
  try {
    const savedCache = localStorage.getItem('tracksCache');
    if (savedCache) {
      const parsedCache = JSON.parse(savedCache);

      // Validate cache entries and remove expired ones
      const now = Date.now();
      Object.keys(parsedCache).forEach(key => {
        const entry = parsedCache[key];
        if (entry && entry.timestamp && now - entry.timestamp < entry.expiryTime) {
          tracksCache[key] = entry;
        }
      });
    }
  } catch (error) {
    console.error('Error loading cache from localStorage:', error);
  }
};

// Initialize cache on module load
if (typeof window !== 'undefined') {
  initializeCache();
}

// Save cache to localStorage
const saveCache = () => {
  if (typeof window !== 'undefined') {
    try {
      localStorage.setItem('tracksCache', JSON.stringify(tracksCache));
    } catch (error) {
      console.error('Error saving cache to localStorage:', error);
    }
  }
};

export const useTracks = (options?: {
  trackNames?: string[],
  page?: number,
  limit?: number
}) => {
  const { trackNames = [], page = 1, limit = 10 } = options || {};

  const [tracks, setTracks] = useState<Track[]>([]);
  const [allTracks, setAllTracks] = useState<Track[]>([]);  // Store all tracks across pages
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [totalTracks, setTotalTracks] = useState(0);
  const [totalPages, setTotalPages] = useState(1);
  const [currentPage, setCurrentPage] = useState(page);
  const isMountedRef = useRef(true);
  const abortControllerRef = useRef<AbortController | null>(null);
  const loadedPagesRef = useRef<Set<number>>(new Set());

  const {
    playTrackAtIndex,
    isPlaying,
    togglePlayPause,
    currentTime,
    duration
  } = useAudio();

  // Create a stable cache key that includes pagination information
  const cacheKey = useMemo(() => {
    const baseKey = trackNames.length > 0 ? trackNames.sort().join(',') : 'all-tracks';
    return `${baseKey}-page${currentPage}-limit${limit}`;
  }, [trackNames, currentPage, limit]);

  // Handle page change
  const goToPage = useCallback((newPage: number) => {
    setCurrentPage(newPage);
  }, []);

  useEffect(() => {
    // Set up AbortController for fetch
    abortControllerRef.current = new AbortController();
    isMountedRef.current = true;

    const fetchTracks = async () => {
      try {
        abortControllerRef.current = new AbortController();
        isMountedRef.current = true;

        // Check cache first
        const cachedData = tracksCache[cacheKey];
        const now = Date.now();

        if (cachedData && (now - cachedData.timestamp) < cachedData.expiryTime) {
          if (isMountedRef.current) {
            setTracks(cachedData.data);

            // Update all tracks if this page wasn't loaded before
            if (!loadedPagesRef.current.has(currentPage)) {
              loadedPagesRef.current.add(currentPage);

              // Use functional update to avoid dependency on allTracks
              setAllTracks(prevAllTracks => {
                const newAllTracks = [...prevAllTracks];
                const startIndex = (currentPage - 1) * limit;

                // Ensure the array is large enough
                if (newAllTracks.length < startIndex + cachedData.data.length) {
                  newAllTracks.length = Math.max(newAllTracks.length, startIndex + cachedData.data.length);
                }

                // Add the tracks from this page to the right positions
                for (let i = 0; i < cachedData.data.length; i++) {
                  newAllTracks[startIndex + i] = cachedData.data[i];
                }

                // Filter out any undefined entries
                return newAllTracks.filter(track => track !== undefined);
              });
            }

            setTotalTracks(cachedData.total !== undefined ? cachedData.total : cachedData.data.length);
            setTotalPages(cachedData.totalPages || 1);
            setIsLoading(false);
          }
          return;
        }

        if (isMountedRef.current) setIsLoading(true);

        // Build URL with pagination parameters
        const queryParams = new URLSearchParams();
        queryParams.append('page', currentPage.toString());
        queryParams.append('limit', limit.toString());

        // Add track names if provided
        if (trackNames.length > 0) {
          trackNames.forEach(name => queryParams.append('tracks', name));
        }

        const url = `/api/tracks?${queryParams.toString()}`;

        const response = await fetch(url, {
          signal: abortControllerRef.current?.signal,
          headers: {
            'Cache-Control': 'max-age=6000',
          },
        });

        if (!response.ok) {
          throw new Error(`Failed to fetch tracks: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();

        if (data && data.tracks && Array.isArray(data.tracks)) {
          // Update cache with pagination metadata
          tracksCache[cacheKey] = {
            data: data.tracks,
            timestamp: now,
            expiryTime: CACHE_EXPIRY,
            total: data.total,
            totalPages: data.totalPages
          };

          // Save cache to localStorage
          saveCache();

          if (isMountedRef.current) {
            setTracks(data.tracks);

            // Update allTracks by merging in these new tracks
            loadedPagesRef.current.add(currentPage);
            const newAllTracks = [...allTracks];
            const startIndex = (currentPage - 1) * limit;

            // Ensure the array is large enough
            if (newAllTracks.length < startIndex + data.tracks.length) {
              newAllTracks.length = Math.max(newAllTracks.length, startIndex + data.tracks.length);
            }

            // Add the tracks from this page to the right positions
            for (let i = 0; i < data.tracks.length; i++) {
              newAllTracks[startIndex + i] = data.tracks[i];
            }

            // Filter out any undefined entries
            setAllTracks(prevAllTracks => {
              const newAllTracks = [...prevAllTracks];
              const startIndex = (currentPage - 1) * limit;

              // Ensure the array is large enough
              if (newAllTracks.length < startIndex + data.tracks.length) {
                newAllTracks.length = Math.max(newAllTracks.length, startIndex + data.tracks.length);
              }

              // Add the tracks from this page to the right positions
              for (let i = 0; i < data.tracks.length; i++) {
                newAllTracks[startIndex + i] = data.tracks[i];
              }

              // Filter out any undefined entries
              return newAllTracks.filter(track => track !== undefined);
            });

            setTotalTracks(data.total);
            setTotalPages(data.totalPages);
            setError(null);
          }
        } else {
          if (isMountedRef.current) {
            setError('No tracks found or invalid response format.');
          }
        }
      } catch (err) {
        // Don't log aborted requests as errors
        if (err instanceof DOMException && err.name === 'AbortError') {
          return;
        }

        console.error('Error fetching tracks:', err);
        if (isMountedRef.current) {
          setError(err instanceof Error ? err.message : 'Unknown error fetching tracks');
        }
      } finally {
        if (isMountedRef.current) {
          setIsLoading(false);
        }
      }
    };

    fetchTracks();

    return () => {
      isMountedRef.current = false;
      abortControllerRef.current?.abort();
    };
  }, [cacheKey, currentPage, limit, trackNames]);

  // Modified track selection handler that uses allTracks for context
  const handleTrackSelect = useCallback((index: number, trackList?: Track[]) => {
    // If trackList is provided, use it directly
    if (trackList && trackList.length > 0) {
      playTrackAtIndex(index, trackList);
      return;
    }

    // Otherwise use our accumulated allTracks, falling back to current page tracks
    const tracksToUse = allTracks.length > 0 ? allTracks : tracks;
    playTrackAtIndex(index, tracksToUse);
  }, [playTrackAtIndex, tracks, allTracks]);

  // Return memoized values with pagination metadata and allTracks
  return useMemo(() => ({
    tracks,
    allTracks,  // Include all accumulated tracks
    isPlaying,
    isLoading,
    error,
    currentTime,
    duration,
    totalTracks,
    totalPages,
    currentPage,
    goToPage,
    handleTrackSelect,
    handlePlayPauseToggle: togglePlayPause
  }), [
    tracks,
    allTracks,
    isPlaying,
    isLoading,
    error,
    currentTime,
    duration,
    totalTracks,
    totalPages,
    currentPage,
    goToPage,
    handleTrackSelect,
    togglePlayPause
  ]);
};

/fetchtracks.tsx

"use client"

import Image from 'next/image';

import { Play, Pause } from 'lucide-react';
import { SoundWave } from '../ui/magic/SoundWave';
import { LikeButton } from '@/components/shared/LikeButton';
import {
  Pagination,
  PaginationContent,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious
} from "@/components/ui/pagination";

import { PlaylistActions } from './PlaylistActions';
import { useAudio } from '@/components/player/AudioContext';
import {
  memo,
  useMemo,
  useCallback,
  useRef,
  useEffect,
  useState
} from 'react';

interface TrackItemProps {
  track: Track;
  index: number;
  isPlaying: boolean;
  handleTrackSelect: (index: number) => void;
}

// Memoized TrackItem component to prevent unnecessary re-renders
const TrackItem = memo(({ track, index, isPlaying, handleTrackSelect }: TrackItemProps) => {
  // Use useCallback for event handlers to maintain referential equality
  const handleClick = useCallback(() => {
    handleTrackSelect(index);
  }, [handleTrackSelect, index]);

  // Rest of TrackItem component stays the same
  return (
    <div
      className="relative flex flex-col items-start group cursor-pointer min-w-[150px] sm:min-w-[200px]"
    >
      <div
        className="relative w-full"
        onClick={handleClick}
      >
        <Image
          src={track.cover || '/default-cover.jpg'}
          alt={track.title}
          width={200}
          height={200}
          className="rounded-lg w-full object-cover"
          // Add priority loading for visible tracks
          priority={index < 4}
        />
        <div className="absolute flex items-end justify-end inset-0 p-4 z-10">
          <LikeButton
            trackId={track.id}
            size="md"
            className="ml-2 bg-white/50 glassmorphism p-2 rounded-full shadow-lg"
          />
        </div>

        {isPlaying && (
          <div className="absolute flex items-center justify-center inset-0 transition-opacity duration-200 bg-black/20 backdrop-blur-[3px] rounded-lg">
            <SoundWave dark />
          </div>
        )}

        <div className="absolute flex items-center justify-center inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-200 bg-black/20 backdrop-blur-[3px] rounded-lg">
          {isPlaying ? (
            <Pause className="w-8 h-8 text-white" />
          ) : (
            <Play className="w-8 h-8 text-white" />
          )}
        </div>
      </div>

      <div className="mt-2 sm:mt-4 text-start w-full flex items-center justify-between">
        <div onClick={handleClick}>
          <h3 className="font-semibold">{track.title}</h3>
          <p className="text-sm text-gray-500">{track.author}</p>
        </div>
        <PlaylistActions trackId={track.id} />
      </div>
    </div>
  );
});

TrackItem.displayName = 'TrackItem';

// Memoized ListTrackItem component
const ListTrackItem = memo(({ track, index, isPlaying, handleTrackSelect }: TrackItemProps) => {
  const handleClick = useCallback(() => {
    handleTrackSelect(index);
  }, [handleTrackSelect, index]);

  // Rest of the ListTrackItem remains the same
  return (
    <div
      className={`flex items-center p-3 hover:bg-neutral-100 hover:rounded-xl cursor-pointer ${isPlaying ? 'bg-neutral-100 rounded-xl' : ''}`}
    >
      <div
        className="flex items-center flex-1 min-w-0"
        onClick={handleClick}
      >
        <div className="relative flex-shrink-0 w-12 h-12 mr-3">
          <Image
            src={track.cover || '/default-cover.jpg'}
            alt={track.title}
            width={48}
            height={48}
            className="rounded object-cover"
            priority={index < 5}
          />

          {isPlaying && (
            <div className="absolute flex items-center justify-center inset-0 transition-opacity duration-200 bg-black/20 backdrop-blur-[3px] rounded-sm">
              <SoundWave dark />
            </div>
          )}
        </div>

        <div className="min-w-0 flex-1">
          <h4 className="font-medium truncate">{track.title}</h4>
          <p className="text-sm text-gray-500 truncate">{track.author}</p>
        </div>
      </div>

      <div className="flex items-center gap-4">
        <LikeButton trackId={track.id} size="md" />
        <PlaylistActions trackId={track.id} />
      </div>
    </div>
  );
});

ListTrackItem.displayName = 'ListTrackItem';

// Create a global cache for track states
const trackStateCache = new Map<string, { isPlaying: boolean }>();

interface FetchTracksProps {
  tracks: Track[];
  isLoading: boolean;
  error: string | null;
  handleTrackSelect: (index: number) => void;
  layout?: 'blocks' | 'list';
  variant?: 'flex' | 'grid';
  totalPages?: number;
  currentPage?: number;
  goToPage?: (page: number) => void;
};

export const FetchTracks = memo(({
  tracks,
  isLoading,
  error,
  handleTrackSelect,
  layout = 'blocks',
  variant = 'flex',
  totalPages = 1,
  currentPage = 1,
  goToPage = () => { }
}: FetchTracksProps) => {
  const { isPlaying, currentTrackIndex, tracks: currentTracks } = useAudio();

  // Keep track of all tracks across all pages
  const tracksRef = useRef<Track[]>([]);
  const limit = tracks.length || 10;

  // Update our ref when tracks change
  useEffect(() => {
    // We need to ensure we maintain the same tracks array structure
    // Update only the section for the current page
    const startIndex = (currentPage - 1) * limit;

    // Initialize the array if needed
    if (!tracksRef.current || tracksRef.current.length === 0) {
      tracksRef.current = new Array(limit * totalPages).fill(null);
    }

    // Update the section of the array for the current page
    for (let i = 0; i < tracks.length; i++) {
      tracksRef.current[startIndex + i] = tracks[i];
    }
  }, [tracks, currentPage, limit, totalPages]);

  // Check if a track is the currently playing track (memoized)
  const getTrackPlayingState = useCallback((track: Track) => {
    if (!isPlaying) return false;
    const currentTrack = currentTracks[currentTrackIndex];
    return currentTrack && currentTrack.id === track.id;
  }, [isPlaying, currentTrackIndex, currentTracks]);

  // Add this useEffect to update the trackStateCache when tracks or playing state changes
  useEffect(() => {
    // Update cache when tracks change or playing state changes
    tracks.forEach(track => {
      const isTrackPlaying = getTrackPlayingState(track);
      trackStateCache.set(track.id, {
        isPlaying: isTrackPlaying
      });
    });
  }, [tracks, getTrackPlayingState]);

  // Optional: Add this to use the cache for performance optimization
  const isTrackPlaying = useCallback((track: Track) => {
    // Check cache first
    const cachedState = trackStateCache.get(track.id);
    if (cachedState !== undefined) {
      return cachedState.isPlaying;
    }
    // Fall back to computing the value
    const isPlaying = getTrackPlayingState(track);
    // Update cache
    trackStateCache.set(track.id, { isPlaying });
    return isPlaying;
  }, [getTrackPlayingState]);

  // Create a function that calculates the absolute index for a track
  const calculateAbsoluteIndex = useCallback((localIndex: number) => {
    return (currentPage - 1) * limit + localIndex;
  }, [currentPage, limit]);

  // Create modified handleTrackSelect that uses our ref to get all tracks
  const handleTrackSelectWithPagination = useCallback((localIndex: number) => {
    // Calculate absolute index
    const absoluteIndex = calculateAbsoluteIndex(localIndex);

    // Call original handler with the filtered tracks array and absolute index
    handleTrackSelect(absoluteIndex);
  }, [calculateAbsoluteIndex, handleTrackSelect]);

  // For loading state
  if (isLoading) {
    return <div className="text-start py-4">Загружаем песни...</div>;
  }

  // For error state
  if (error) {
    return <div className="text-center text-red-500 py-4">{error}</div>;
  }

  // For empty state
  if (tracks.length === 0) {
    return <div className="text-start py-4">Песни не найдены.</div>;
  }

  // Render pagination component
  const renderPagination = () => {
    if (totalPages <= 1) return null;

    return (
      <Pagination className="mt-6">
        <PaginationContent>
          <PaginationItem>
            <PaginationPrevious
              onClick={() => goToPage(Math.max(1, currentPage - 1))}
              className={currentPage === 1 ? "pointer-events-none opacity-50 text-purple-800" : "cursor-pointer bg-purple-200/50 text-purple-800"}
            />
          </PaginationItem>

          {Array.from({ length: totalPages }, (_, i) => i + 1).map(page => (
            <PaginationItem key={page}>
              <PaginationLink
                onClick={() => goToPage(page)}
                isActive={currentPage === page}
                className="cursor-pointer"
              >
                {page}
              </PaginationLink>
            </PaginationItem>
          ))}

          <PaginationItem>
            <PaginationNext
              onClick={() => goToPage(Math.min(totalPages, currentPage + 1))}
              className={currentPage === totalPages ? "pointer-events-none opacity-50 text-purple-800" : "cursor-pointer bg-purple-200/50 text-purple-800"}
            />
          </PaginationItem>
        </PaginationContent>
      </Pagination>
    );
  };

  // Render tracks in block layout (grid or flex of cards)
  if (layout === 'blocks') {
    return (
      <div className="flex flex-col w-full">
        <div className={variant === 'grid'
          ? "grid grid-cols-2 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"
          : "flex flex-row overflow-x-auto overflow-y-hidden gap-4 w-full"
        }>
          {tracks.map((track, index) => (
            <TrackItem
              key={track.id}
              track={track}
              index={calculateAbsoluteIndex(index)}
              isPlaying={isTrackPlaying(track)}
              handleTrackSelect={handleTrackSelectWithPagination}
            />
          ))}
        </div>
        {renderPagination()}
      </div>
    );
  }

  // Render list layout
  return (
    <div className="flex flex-col w-full">
      <div className="bg-sidebar glassmorphism w-full border border-neutral-200 rounded-xl divide-y">
        {tracks.map((track, index) => (
          <ListTrackItem
            key={track.id}
            track={track}
            index={calculateAbsoluteIndex(index)}
            isPlaying={isTrackPlaying(track)}
            handleTrackSelect={handleTrackSelectWithPagination}
          />
        ))}
      </div>
      {renderPagination()}
    </div>
  );
});

FetchTracks.displayName = 'FetchTracks';