db/index
import Dexie, { Table } from 'dexie';
import { Track } from './models/tracks.model';
import { User } from './models/user.model';

export class Database extends Dexie {
    tracks!: Table<Track>;
    users!: Table<User>;

    constructor() {
        super('Database');
        this.version(1).stores({
            tracks: 'id, title, author, album, src, cover, type',
            users: 'id, name, onboarding',
        });
    }
}

// Create a single instance of the database to be used throughout the app
const db = new Database();

export default db;

db/actions/track.actions.ts
import db from '../index';
import { Track } from '../models/tracks.model';

export async function syncTracksFromAPI(): Promise<Track[]> {
    try {
        // Fetch tracks from the API
        const response = await fetch('/api/tracks');
        if (!response.ok) {
            throw new Error(`Failed to fetch tracks: ${response.status}`);
        }

        const newTracks: Track[] = await response.json();

        // Store tracks in the database while preserving existing tracks
        await db.transaction('rw', db.tracks, async () => {
            // Get existing tracks
            const existingTracks = await db.tracks.toArray();
            const existingIds = new Set(existingTracks.map(track => track.id));

            // Add only new tracks
            const tracksToAdd = newTracks.filter(track => !existingIds.has(track.id));

            // Update existing tracks
            const tracksToUpdate = newTracks.filter(track => existingIds.has(track.id));

            // Add new tracks
            if (tracksToAdd.length > 0) {
                await db.tracks.bulkAdd(tracksToAdd);
            }

            // Update existing tracks
            for (const track of tracksToUpdate) {
                await db.tracks.update(track.id, track);
            }
        });

        return newTracks;
    } catch (error) {
        console.error('Error syncing tracks:', error);
        throw error;
    }
}

// Get all tracks from the database
export async function getAllTracks(): Promise<Track[]> {
    return await db.tracks.toArray();
}

// Get a track by ID
export async function getTrackById(id: string): Promise<Track | undefined> {
    return await db.tracks.get(id);
}

// Get tracks by IDs
export async function getTracksByIds(ids: string[]): Promise<Track[]> {
    return await db.tracks.where('id').anyOf(ids).toArray();
}

// Search tracks by title or author
export async function searchTracks(query: string): Promise<Track[]> {
    const lowerQuery = query.toLowerCase();

    return await db.tracks.filter((track: Track) => {
        const titleMatch = track.title.toLowerCase().includes(lowerQuery);
        const authorMatch = track.author ? track.author.toLowerCase().includes(lowerQuery) : false;

        return titleMatch || authorMatch;
    }).toArray();
}

db/actions/user.actions.ts
import db from '../index';

import { v4 as uuidv4 } from 'uuid';
import { User, Playlist } from '../models/user.model';
import { Track } from '../models/tracks.model';
import { getTracksByIds } from './tracks.actions';

// Get the current user (create one if it doesn't exist)
export async function getCurrentUser(): Promise<User> {
    const users = await db.users.toArray();

    if (users.length === 0) {
        // Create a default user if none exists
        const newUser: User = {
            id: uuidv4(),
            name: 'User',
            likedSongs: [],
            playlists: [],
            onboarding: false
        };

        await db.users.add(newUser);
        return newUser;
    }

    // Return the first user (we're only supporting one user in this simple app)
    return users[0];
}

// Update user name and complete onboarding
export async function completeOnboarding(name: string): Promise<User> {
    const user = await getCurrentUser();

    const updatedUser: User = {
        ...user,
        name,
        onboarding: true
    };

    await db.users.update(user.id, {
        name: updatedUser.name,
        onboarding: updatedUser.onboarding
    });
    return updatedUser;
}

// Check if user has completed onboarding
export async function hasCompletedOnboarding(): Promise<boolean> {
    const user = await getCurrentUser();
    return user.onboarding;
}

// Add a track to liked songs
export async function likeSong(trackId: string): Promise<void> {
    const user = await getCurrentUser();

    if (!user.likedSongs.includes(trackId)) {
        const updatedUser: User = {
            ...user,
            likedSongs: [...user.likedSongs, trackId]
        };

        await db.users.update(user.id, {
            likedSongs: updatedUser.likedSongs
        });
    }
}

// Remove a track from liked songs
export async function unlikeSong(trackId: string): Promise<void> {
    const user = await getCurrentUser();

    const updatedUser: User = {
        ...user,
        likedSongs: user.likedSongs.filter(id => id !== trackId)
    };

    await db.users.update(user.id, {
        likedSongs: updatedUser.likedSongs
    });
}

// Check if a song is liked
export async function isSongLiked(trackId: string): Promise<boolean> {
    const user = await getCurrentUser();
    return user.likedSongs.includes(trackId);
}

// Get all liked songs
export async function getLikedSongs(): Promise<Track[]> {
    const user = await getCurrentUser();
    return await getTracksByIds(user.likedSongs);
}

// Create a new playlist
export async function createPlaylist(name: string): Promise<Playlist> {
    const user = await getCurrentUser();

    const newPlaylist: Playlist = {
        id: uuidv4(),
        name,
        tracks: [],
        createdAt: new Date()
    };

    const updatedUser: User = {
        ...user,
        playlists: [...user.playlists, newPlaylist]
    };

    await db.users.update(user.id, {
        playlists: updatedUser.playlists
    });
    return newPlaylist;
}

// Add a track to a playlist
export async function addTrackToPlaylist(playlistId: string, trackId: string): Promise<void> {
    const user = await getCurrentUser();

    const updatedPlaylists = user.playlists.map(playlist => {
        if (playlist.id === playlistId && !playlist.tracks.includes(trackId)) {
            return {
                ...playlist,
                tracks: [...playlist.tracks, trackId]
            };
        }
        return playlist;
    });

    const updatedUser: User = {
        ...user,
        playlists: updatedPlaylists
    };

    await db.users.update(user.id, {
        playlists: updatedUser.playlists
    });
}

// Remove a track from a playlist
export async function removeTrackFromPlaylist(playlistId: string, trackId: string): Promise<void> {
    const user = await getCurrentUser();

    const updatedPlaylists = user.playlists.map(playlist => {
        if (playlist.id === playlistId) {
            return {
                ...playlist,
                tracks: playlist.tracks.filter(id => id !== trackId)
            };
        }
        return playlist;
    });

    const updatedUser: User = {
        ...user,
        playlists: updatedPlaylists
    };

    await db.users.update(user.id, {
        playlists: updatedUser.playlists
    });
}

// Delete a playlist
export async function deletePlaylist(playlistId: string): Promise<void> {
    const user = await getCurrentUser();

    const updatedUser: User = {
        ...user,
        playlists: user.playlists.filter(playlist => playlist.id !== playlistId)
    };

    await db.users.update(user.id, {
        playlists: updatedUser.playlists
    });
}

// Rename a playlist
export async function renamePlaylist(playlistId: string, newName: string): Promise<void> {
    const user = await getCurrentUser();

    const updatedPlaylists = user.playlists.map(playlist => {
        if (playlist.id === playlistId) {
            return {
                ...playlist,
                name: newName
            };
        }
        return playlist;
    });

    const updatedUser: User = {
        ...user,
        playlists: updatedPlaylists
    };

    await db.users.update(user.id, {
        playlists: updatedUser.playlists
    });
}

// Get a playlist by ID with its tracks
export async function getPlaylistWithTracks(playlistId: string): Promise<{ playlist: Playlist, tracks: Track[] } | null> {
    const user = await getCurrentUser();

    const playlist = user.playlists.find(p => p.id === playlistId);
    if (!playlist) return null;

    const tracks = await getTracksByIds(playlist.tracks);

    return { playlist, tracks };
}

// Get all playlists
export async function getAllPlaylists(): Promise<Playlist[]> {
    const user = await getCurrentUser();
    return user.playlists;
}

db/models/user.model.ts
export interface User {
    id: string;
    name: string;
    likedSongs: string[]; // Array of track IDs
    playlists: Playlist[];
    onboarding: boolean;
}

export interface Playlist {
    id: string;
    name: string;
    tracks: string[]; // Array of track IDs
    createdAt: Date;
}
db/models/tracks.model.ts
export interface Track {
    id: string;
    title: string;
    author: string;
    album?: string;
    src: string;
    cover?: string;
    type?: string;
}
import { useState, useEffect, useCallback } from 'react';
import {
    createPlaylist,
    addTrackToPlaylist,
    getAllPlaylists,
    getPlaylistWithTracks,
    getCurrentUser,
    removeTrackFromPlaylist,
    deletePlaylist
} from '@/db/actions/user.actions';
import { Playlist } from '@/db/models/user.model';

export const usePlaylist = (trackId?: string) => {
    const [playlists, setPlaylists] = useState<Playlist[]>([]);
    const [isLoading, setIsLoading] = useState(true);

    const fetchPlaylists = useCallback(async () => {
        try {
            setIsLoading(true);
            const userPlaylists = await getAllPlaylists();
            setPlaylists(userPlaylists);
        } catch (error) {
            console.error('Error loading playlists:', error);
        } finally {
            setIsLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchPlaylists();
    }, [fetchPlaylists]);

    const addToPlaylist = useCallback(async (playlistId: string) => {
        if (!trackId) return false;

        try {
            await addTrackToPlaylist(playlistId, trackId);
            // Refresh playlists to reflect the changes
            await fetchPlaylists();
            return true;
        } catch (error) {
            console.error('Error adding to playlist:', error);
            return false;
        }
    }, [trackId, fetchPlaylists]);

    const removeFromPlaylist = useCallback(async (playlistId: string) => {
        if (!trackId) return false;

        try {
            await removeTrackFromPlaylist(playlistId, trackId);
            // Refresh playlists to reflect the changes
            await fetchPlaylists();
            return true;
        } catch (error) {
            console.error('Error removing from playlist:', error);
            return false;
        }
    }, [trackId, fetchPlaylists]);

    const createNewPlaylist = useCallback(async (name: string) => {
        try {
            const newPlaylist = await createPlaylist(name);

            if (trackId) {
                await addTrackToPlaylist(newPlaylist.id, trackId);
            }

            // Refresh playlists to reflect the changes
            await fetchPlaylists();
            return newPlaylist;
        } catch (error) {
            console.error('Error creating playlist:', error);
            return null;
        }
    }, [trackId, fetchPlaylists]);

    const removePlaylist = useCallback(async (playlistId: string) => {
        try {
            await deletePlaylist(playlistId);
            await fetchPlaylists();
            return true;
        } catch (error) {
            console.error('Error deleting playlist:', error);
            return false;
        }
    }, [fetchPlaylists]);

    const renamePlaylist = useCallback(async (playlistId: string, newName: string) => {
        try {
            await renamePlaylist(playlistId, newName);
            await fetchPlaylists();
            return true;
        } catch (error) {
            console.error('Error renaming playlist:', error);
            return false;
        }
    }, [playlists, fetchPlaylists]);


    const isTrackInPlaylist = useCallback((playlistId: string): boolean => {
        if (!trackId) return false;

        const playlist = playlists.find(p => p.id === playlistId);
        return playlist ? playlist.tracks.includes(trackId) : false;
    }, [playlists, trackId]);

    const getPlaylistById = useCallback(async (playlistId: string) => {
        try {
            return await getPlaylistWithTracks(playlistId);
        } catch (error) {
            console.error('Error getting playlist:', error);
            return null;
        }
    }, []);

    return {
        playlists,
        isLoading,
        addToPlaylist,
        removeFromPlaylist,
        createNewPlaylist,
        removePlaylist,
        renamePlaylist,
        isTrackInPlaylist,
        getPlaylistById,
        refreshPlaylists: fetchPlaylists
    };
};

/components/shader/FetchTracks
"use client"

import Image from 'next/image';

import { memo } from 'react';
import { Play, Pause } from 'lucide-react';
import { SoundWave } from '../ui/magic/SoundWave';
import { PlaylistActions } from './PlaylistActions';
import { useAudio } from '@/components/player/AudioContext';
import { LikeButton } from '@/components/shared/LikeButton';

interface FetchTracksProps {
  tracks: Track[];
  isLoading: boolean;
  error: string | null;
  handleTrackSelect: (index: number) => void;
  layout?: 'blocks' | 'list';
  variant?: 'flex' | 'grid';
}

export const FetchTracks = memo(({
  tracks,
  isLoading,
  error,
  handleTrackSelect,
  layout = 'blocks',
  variant = 'flex'
}: FetchTracksProps) => {
  const { isPlaying, currentTrackIndex, tracks: currentTracks } = useAudio();

  // Check if a track is the currently playing track
  const isTrackPlaying = (track: Track) => {
    if (!isPlaying) return false;

    const currentTrack = currentTracks[currentTrackIndex];
    return currentTrack && currentTrack.id === track.id;
  };

  if (isLoading) {
    return <div className="text-start py-4">Заргужаем песни...</div>;
  }

  if (error) {
    return <div className="text-center text-red-500 py-4">{error}</div>;
  }

  if (tracks.length === 0) {
    return <div className="text-start py-4">Песни не найдены.</div>;
  }

  // Render tracks in block layout (grid or flex of cards)
  if (layout === 'blocks') {
    return (
      <div className={variant === 'grid'
        ? "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4"
        : "flex flex-row overflow-x-auto overflow-y-hidden gap-4 w-full"
      }>
        {tracks.map((track, index) => (
          <div
            key={track.id}
            className="relative flex flex-col items-start group cursor-pointer min-w-[150px] sm:min-w-[200px]"
          >
            <div
              className="relative w-full"
              onClick={() => handleTrackSelect(index)}
            >
              <Image
                src={track.cover || '/default-cover.jpg'}
                alt={track.title}
                width={200}
                height={200}
                className="rounded-lg w-full object-cover"
              />
              <div className="absolute flex items-end justify-end inset-0 p-4 z-10">
                <LikeButton trackId={track.id} size="md" className="ml-2 bg-white/50 glassmorphism p-2 rounded-full shadow-lg" />
              </div>

              {isTrackPlaying(track) &&
                <div className="absolute flex items-center justify-center inset-0 transition-opacity duration-200 bg-black/20 backdrop-blur-[3px] rounded-lg">
                  <SoundWave dark />
                </div>
              }

              <div className="absolute flex items-center justify-center inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-200 bg-black/20 backdrop-blur-[3px] rounded-lg">
                {isTrackPlaying(track) ? (
                  <Pause className="w-8 h-8 text-white" />
                ) : (
                  <Play className="w-8 h-8 text-white" />
                )}
              </div>
            </div>

            <div className="mt-2 sm:mt-4 text-start w-full flex items-center justify-between">
              <div onClick={() => handleTrackSelect(index)}>
                <h3 className="font-semibold">{track.title}</h3>
                <p className="text-sm text-gray-500">{track.author}</p>
              </div>
              <PlaylistActions trackId={track.id} />
            </div>
          </div>
        ))}
      </div>
    );
  }

  // Render tracks in list layout (Spotify-like list)
  return (
    <div className="bg-sidebar glassmorphism w-full border border-neutral-200 rounded-xl divide-y">
      {tracks.map((track, index) => (
        <div
          key={track.id}
          className={`flex items-center p-3 hover:bg-neutral-100 hover:rounded-xl cursor-pointer ${isTrackPlaying(track) ? 'bg-neutral-100 rounded-xl' : ''}`}
        >
          <div
            className="flex items-center flex-1 min-w-0"
            onClick={() => handleTrackSelect(index)}
          >
            <div className="relative flex-shrink-0 w-12 h-12 mr-3">
              <Image
                src={track.cover!}
                alt={track.title}
                width={48}
                height={48}
                className="rounded object-cover"
              />

              {isTrackPlaying(track) &&
                <div className="absolute flex items-center justify-center inset-0 transition-opacity duration-200 bg-black/20 backdrop-blur-[3px] rounded-lg">
                  <SoundWave dark />
                </div>
              }
            </div>

            <div className="min-w-0 flex-1">
              <h4 className="font-medium truncate">{track.title}</h4>
              <p className="text-sm text-gray-500 truncate">{track.author}</p>
            </div>
          </div>

          <div className="flex items-center gap-4">
            <LikeButton trackId={track.id} size="md" />
            <PlaylistActions trackId={track.id} />
          </div>
        </div>
      ))}
    </div>
  );
});
hooks/useTracks
"use client"

import { useState, useEffect, useCallback } from "react";
import { useAudio } from "@/components/player/AudioContext";
import { Track } from "@/db/models/tracks.model"; // Import the Track type from your models

export const useTracks = (...trackNames: string[]) => {
  const [tracks, setTracks] = useState<Track[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const { 
    playTrackAtIndex,
    isPlaying,
    togglePlayPause,
    currentTime,
    duration
  } = useAudio();

  useEffect(() => {
    const fetchTracks = async () => {
      try {
        setIsLoading(true);

        let url = '/api/tracks';
        // If track names are provided, add them as query parameters
        if (trackNames.length > 0) {
          const queryParams = new URLSearchParams();
          trackNames.forEach(name => queryParams.append('tracks', name));
          url = `${url}?${queryParams.toString()}`;
        }

        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`Failed to fetch tracks: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();

        if (Array.isArray(data) && data.length > 0) {
          setTracks(data);
        } else {
          setError('No tracks found. Please add some music files to the tracks directory.');
        }
      } catch (err) {
        console.error('Error fetching tracks:', err);
        setError(err instanceof Error ? err.message : 'Unknown error fetching tracks');
      } finally {
        setIsLoading(false);
      }
    };

    fetchTracks();
  }, [trackNames.join(',')]); // Re-fetch when track list changes

  // Handle track selection
  const handleTrackSelect = useCallback((index: number) => {
    playTrackAtIndex(index, tracks);
  }, [playTrackAtIndex, tracks]);

  return {
    tracks,
    isPlaying,
    isLoading,
    error,
    currentTime,
    duration,
    handleTrackSelect,
    handlePlayPauseToggle: togglePlayPause
  };
};

/components/shared/playlist preview
"use client"

import Link from 'next/link';
import { useState } from 'react';
import { Music, EllipsisVertical, Pencil, Trash2 } from 'lucide-react';
import { Playlist } from '@/db/models/user.model';
import { usePlaylist } from '@/hooks/usePlaylist';

import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuSeparator,
    DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
    Dialog,
    DialogContent,
    DialogDescription,
    DialogFooter,
    DialogHeader,
    DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

interface PlaylistPreviewProps {
    playlist: Playlist;
    trackCount?: number;
}

export const PlaylistPreview = ({ playlist, trackCount }: PlaylistPreviewProps) => {
    const { removePlaylist, renamePlaylist, refreshPlaylists } = usePlaylist();
    const [isRenameDialogOpen, setIsRenameDialogOpen] = useState(false);
    const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
    const [newPlaylistName, setNewPlaylistName] = useState(playlist.name);

    // Generate a random gradient for each playlist
    const generateGradient = () => {
        const gradients = [
            'from-blue-600 to-purple-600',
            'from-green-600 to-teal-600',
            'from-purple-600 to-pink-600',
            'from-yellow-600 to-orange-600',
            'from-red-600 to-pink-600',
            'from-blue-600 to-cyan-600',
            'from-indigo-600 to-purple-600',
        ];

        // Use a hash of the playlist ID to ensure consistent colors for the same playlist
        const index = playlist.id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) % gradients.length;
        return gradients[index];
    };

    const handleDeletePlaylist = async () => {
        await removePlaylist(playlist.id);
        setIsDeleteDialogOpen(false);
    };

    const handleRenamePlaylist = async (e: React.FormEvent) => {
        e.preventDefault();

        await renamePlaylist(playlist.id, newPlaylistName);

        setIsRenameDialogOpen(false);
        refreshPlaylists();
    };

    const handleMenuClick = (e: React.MouseEvent) => {
        // Prevent click from triggering the Link navigation
        e.preventDefault();
        e.stopPropagation();
    };

    return (
        <div className="relative group">
            <Link href={`/playlist/${playlist.id}`}>
                <div className={`relative w-full h-40 rounded-lg overflow-hidden shadow-md cursor-pointer hover:shadow-lg transition-all duration-300 bg-gradient-to-br ${generateGradient()}`}>
                    <div className="absolute inset-0 flex items-center justify-center opacity-70">
                        <Music className="w-20 h-20 text-white opacity-50" />
                    </div>

                    <div className="absolute bottom-0 left-0 right-0 p-4 text-white">
                        <h3 className="font-bold text-lg truncate">{playlist.name}</h3>
                        <p className="text-sm opacity-80">
                            {trackCount !== undefined
                                ? `${trackCount} ${trackCount === 1 ? 'track' : 'tracks'}`
                                : `${playlist.tracks.length} ${playlist.tracks.length === 1 ? 'track' : 'tracks'}`}
                        </p>
                    </div>
                </div>
            </Link>

            {/* Dropdown Menu */}
            <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity" onClick={handleMenuClick}>
                <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="icon" className="rounded-full bg-white/50 glassmorphism focus-visible:ring-0">
                            <EllipsisVertical className="h-5 w-5" />
                            <span className="sr-only">Действия с плейлистом</span>
                        </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end" className="w-56 bg-white/60 glassmorphism">
                        <DropdownMenuItem onClick={() => setIsRenameDialogOpen(true)}>
                            <Pencil className="size-4 mr-1 text-black" />
                            <span>Переименовать</span>
                        </DropdownMenuItem>
                        <DropdownMenuSeparator />
                        <DropdownMenuItem onClick={() => setIsDeleteDialogOpen(true)} className="text-red-500">
                            <Trash2 className="size-4 mr-1 text-red-500" />
                            <span>Удалить</span>
                        </DropdownMenuItem>
                    </DropdownMenuContent>
                </DropdownMenu>
            </div>

            {/* Rename Dialog */}
            <Dialog open={isRenameDialogOpen} onOpenChange={setIsRenameDialogOpen}>
                <DialogContent className="sm:max-w-[425px]">
                    <DialogHeader>
                        <DialogTitle>Переименовать</DialogTitle>
                        <DialogDescription>
                            Введите новое название плейлиста
                        </DialogDescription>
                    </DialogHeader>
                    <form onSubmit={handleRenamePlaylist}>
                        <div className="py-4">
                            <Input
                                value={newPlaylistName}
                                onChange={(e) => setNewPlaylistName(e.target.value)}
                                placeholder="Название плейлиста"
                                className="w-full"
                                autoFocus
                            />
                        </div>
                        <DialogFooter>
                            <Button type="button" variant="outline" onClick={() => setIsRenameDialogOpen(false)}>
                                Отмена
                            </Button>
                            <Button type="submit" disabled={!newPlaylistName.trim()} className="bg-purple-200/50 text-purple-800">
                                Сохранить
                            </Button>
                        </DialogFooter>
                    </form>
                </DialogContent>
            </Dialog>

            {/* Delete Confirmation Dialog */}
            <Dialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>
                <DialogContent className="sm:max-w-[425px]">
                    <DialogHeader>
                        <DialogTitle>Удалить плейлист?</DialogTitle>
                        <DialogDescription>
                            Вы уверены что хотите удалить "{playlist.name}"? Это действие необратимо.
                        </DialogDescription>
                    </DialogHeader>
                    <DialogFooter>
                        <Button type="button" variant="outline" onClick={() => setIsDeleteDialogOpen(false)}>
                            Отмена
                        </Button>
                        <Button type="button" onClick={handleDeletePlaylist} className="bg-red-500 text-white hover:bg-red-700">
                            Удалить
                        </Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>
        </div>
    );
};
/components/playlist grid
"use client"

import { useState, useEffect } from 'react';
import { usePlaylist } from '@/hooks/usePlaylist';
import { PlaylistPreview } from '@/components/shared/PlaylistPreview';
import { Playlist } from '@/db/models/user.model';
import { PlusCircle } from 'lucide-react';
import { Button } from "@/components/ui/button";
import {
    Dialog,
    DialogContent,
    DialogDescription,
    DialogFooter,
    DialogHeader,
    DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";

export const PlaylistGrid = () => {
    const { playlists, isLoading, createNewPlaylist, refreshPlaylists } = usePlaylist();
    const [newPlaylistName, setNewPlaylistName] = useState('');
    const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);

    useEffect(() => {
        refreshPlaylists();
    }, [refreshPlaylists]);

    const handleCreatePlaylist = async (e: React.FormEvent) => {
        e.preventDefault();

        if (!newPlaylistName.trim()) return;

        const newPlaylist = await createNewPlaylist(newPlaylistName);

        if (newPlaylist) {
            setNewPlaylistName('');
            setIsCreateDialogOpen(false);
            refreshPlaylists();
        }
    };

    if (isLoading) {
        return <div className="text-center py-8">Loading playlists...</div>;
    }

    return (
        <div className="w-full">
            <div className="flex items-center justify-between mb-6">
                <h2 className="text-xl font-semibold">Ваши плейлисты</h2>
                <Button
                    onClick={() => setIsCreateDialogOpen(true)}
                    className="flex items-center gap-2 bg-purple-200/50 text-purple-800 hover:bg-purple-300/50"
                >
                    <PlusCircle className="h-4 w-4" />
                    <span>Новый плейлист</span>
                </Button>
            </div>

            {playlists.length === 0 ? (
                <div className="text-center py-8 bg-neutral-100 rounded-xl p-8">
                    <p className="text-neutral-500 mb-4">У вас пока нет плейлистов.</p>
                    <Button
                        onClick={() => setIsCreateDialogOpen(true)}
                        className="bg-purple-200/50 text-purple-800 hover:bg-purple-300/50"
                    >
                        Создайте свой первый плейлист
                    </Button>
                </div>
            ) : (
                <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-6">
                    {playlists.map((playlist) => (
                        <PlaylistPreview key={playlist.id} playlist={playlist} />
                    ))}
                </div>
            )}

            {/* Create Playlist Dialog */}
            <Dialog open={isCreateDialogOpen} onOpenChange={setIsCreateDialogOpen}>
                <DialogContent className="sm:max-w-[425px]">
                    <DialogHeader>
                        <DialogTitle>Создать новый плейлист</DialogTitle>
                        <DialogDescription>
                            Введите название для плейлиста. Позже вы можете добавить в них песни
                        </DialogDescription>
                    </DialogHeader>
                    <form onSubmit={handleCreatePlaylist}>
                        <div className="py-4">
                            <Input
                                value={newPlaylistName}
                                onChange={(e) => setNewPlaylistName(e.target.value)}
                                placeholder="Название плейлиста"
                                className="w-full"
                                autoFocus
                            />
                        </div>
                        <DialogFooter>
                            <Button type="button" variant="outline" onClick={() => setIsCreateDialogOpen(false)}>
                                Отмена
                            </Button>
                            <Button type="submit" disabled={!newPlaylistName.trim()} className="bg-purple-200/50 text-purple-800">
                                Создать
                            </Button>
                        </DialogFooter>
                    </form>
                </DialogContent>
            </Dialog>
        </div>
    );
};